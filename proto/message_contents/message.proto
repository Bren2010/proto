// Messages used for transport and storage of user conversations.
syntax = "proto3";

package xmtp.message_contents;

import "message_contents/ciphertext.proto";
import "message_contents/conversation_reference.proto";
import "message_contents/public_key.proto";

option go_package = "github.com/xmtp/proto/v3/go/message_contents";
option java_package = "org.xmtp.proto.message.contents";

// Message V1

// Message header is encoded separately as the bytes are also used
// as associated data for authenticated encryption
message MessageHeaderV1 {
    PublicKeyBundle sender = 1;
    PublicKeyBundle recipient = 2;
    uint64 timestamp = 3;
}

// Message is the top level protocol element
message MessageV1 {
    bytes header_bytes = 1;  // encapsulates encoded MessageHeaderV1
    // Ciphertext.payload MUST contain encrypted EncodedContent
    Ciphertext ciphertext = 2;
}

// Message V2

// Message header carries information that is not encrypted, and is therefore
// observable by the network. It is however authenticated as associated data
// of the AEAD encryption used to protect the message,
// thus providing tamper evidence.
message MessageHeaderV2 {
    // sender specified message creation time
    uint64 created_ns = 1;
    // the topic the message belongs to
    string topic = 2;
}

// Message combines the encoded header with the encrypted payload.
message MessageV2 {
    bytes header_bytes = 1;  // encapsulates encoded MessageHeaderV2
    // Ciphertext.payload MUST contain encrypted SignedContent
    Ciphertext ciphertext = 2;
}

// Versioned Message
message Message {
    oneof version {
        MessageV1 v1 = 1;
        MessageV2 v2 = 2;
    }
}

// DecodedMessage represents the decrypted message contents.
// DecodedMessage instances are not stored on the network, but
// may be serialized and stored by clients
message DecodedMessage {
    string id = 1;
    string message_version = 2;
    string sender_address = 3;
    optional string recipient_address = 4;
    uint64 sent_ns = 5;
    string content_topic = 6;
    ConversationReference conversation = 7;
    bytes content_bytes = 8;  // encapsulates EncodedContent
}

// Metadata that is encrypted via SealedSender and only visible to the recipient
// Currently we do not actually encrypt this, actual implementation of
// SealedSender will be added shortly.
message PadlockMessageSealedMetadata {
    string sender_user_address = 1;
    string sender_installation_id = 2;
    string recipient_user_address = 3;
    string recipient_installation_id = 4;
}

// Plaintext header included with messages, visible to all
// Recipients can verify this header has not been tampered with.
// Servers are unable to verify if the header has been tampered with.
message PadlockMessageHeader {
    uint64 sent_ns = 1;
    bytes sealed_metadata = 2;  // PadlockMessageSealedMetadata
}

// Encrypted body included with messages, only visible to recipients
// When receiving a message:
// 1. Decrypt the sealed metadata in the header via SealedSender
// 2. Verify that you match the recipient_user_address and
//    recipient_installation_id. Verify that the sender_installation_id matches
//    the sender_user_address.
// 2. Find the relevant session using the sender_user_address and
//    sender_installation_id in the unsealed metadata
// 3. Use the session to decrypt the payload
// 4. Verify that the header_signature in the decrypted payload matches the
//    header bytes
// 5. Verify that the signer of the header_signature matches the
//    sender_installation_id
// 6. Verify that both the sender_user and recipient_user are partipants of the
//    conversation referenced by convo_id
message PadlockMessagePayload {
    uint32 message_version = 1;
    bytes header_signature = 2; // Signature for PadlockMessageHeader 
    string convo_id = 3;
    bytes content_bytes = 4;    // EncodedContent
}

// Combines the plaintext header with the encrypted payload
message PadlockMessageEnvelope {
    bytes header_bytes = 1;     // PadlockMessageHeader
    bytes ciphertext = 2;       // Encrypted PadlockMessagePayload
}