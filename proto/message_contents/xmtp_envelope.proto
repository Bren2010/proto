// Messages used for transport and storage of user conversations.
syntax = "proto3";

package xmtp.message_contents;

import "message_contents/ciphertext.proto";
import "message_contents/public_key.proto";
import "message_contents/signature.proto";

option go_package = "github.com/xmtp/proto/go/message_contents";

// ContentTypeId is used to identify the type of content stored in a Message.
message ContentTypeId {
    string authority_id = 1;  // authority governing this content type
    string type_id = 2;  // type identifier
    uint32 version_major = 3; // major version of the type
    uint32 version_minor = 4; // minor version of the type
}

// Recognized compression algorithms
// protolint:disable ENUM_FIELD_NAMES_ZERO_VALUE_END_WITH
enum Compression {
    COMPRESSION_DEFLATE = 0;
    COMPRESSION_GZIP = 1;
}
// protolint:enable ENUM_FIELD_NAMES_ZERO_VALUE_END_WITH

// EncodedContent bundles the content with metadata identifying its type
// and parameters required for correct decoding and presentation of the content.
message EncodedContent {
    // content type identifier used to match the payload with
    // the correct decoding machinery
    ContentTypeId type = 1;
    // optional encoding parameters required to correctly decode the content
    map<string, string> parameters = 2;
    // optional fallback description of the content that can be used in case
    // the client cannot decode or render the content
    optional string fallback = 3;
    // optional compression; the value indicates algorithm used to
    // compress the encoded content bytes
    optional Compression compression = 5;
    // encoded content itself
    bytes content = 4;
}

// SignedContent attaches a signature to EncodedContent.
message SignedContent {
    // MUST contain EncodedContent
    bytes payload = 1;
    SignedPublicKeyBundle sender = 2;
    // MUST be a signature of a concatenation of the topic name,
    // message header bytes and the payload bytes,
    // signed by the sender's pre-key.
    Signature signature = 3; 
}

// Message V1

// Message header is encoded separately as the bytes are also used
// as associated data for authenticated encryption
message MessageHeaderV1 {
    PublicKeyBundle sender = 1;
    PublicKeyBundle recipient = 2;
    uint64 timestamp = 3;
}

// Message is the top level protocol element
message MessageV1 {
    bytes header_bytes = 1; // encapsulates encoded MessageHeaderV1
    // Ciphertext.payload MUST contain encrypted EncodedContent
    Ciphertext ciphertext = 2; 
}

// Message V2

// Message header carries information that is not encrypted, and is therefore
// observable by the network. It is however authenticated as associated data
// of the AEAD encryption used to protect the message,
// thus providing tamper evidence.
message MessageHeaderV2 {
    // sender specified message creation time
    uint64 created_ns = 1; 
}

// Message combines the encoded header with the encrypted payload.
message MessageV2 {
    bytes header_bytes = 1; // encapsulates encoded MessageHeaderV2
    // Ciphertext.payload MUST contain encrypted SignedContent
    Ciphertext ciphertext = 2;
}


// Versioned Message
message Message {
    oneof version {
        MessageV1 v1 = 1;
        MessageV2 v2 = 2;
    }
}
